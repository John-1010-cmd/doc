---
title: JVM Q&A
date: 2023-05-17
updated : 2023-05-17
categories: 
- Java 
tags: 
- Java
- JVM
description: 这是一篇关于JVM Q&A的Blog。
---

## JVM中的类加载问题

## 对类加载器的理解

## 双亲委派机制

## 运行时数据区

在Java虚拟机（JVM）中，运行时数据区是用于存储程序运行时数据的区域，它包括以下几个部分：

1. 方法区（Method Area）：用于存储类的结构信息、常量池、静态变量、方法字节码等数据。方法区在JDK 8及之前被称为"永久代"（Permanent Generation），在JDK 8及之后被移除，取而代之的是"元空间"（Metaspace）。
2. 堆（Heap）：用于存储对象实例。所有通过关键字`new`创建的对象都会被分配到堆上。堆是Java程序中最大的一块内存区域，也是垃圾回收的主要区域。
3. Java栈（Java Stack）：用于存储线程的方法调用和局部变量等信息。每个线程在执行过程中都会创建一个对应的Java栈，栈中包含多个栈帧，每个栈帧对应一个方法的调用。
4. 本地方法栈（Native Method Stack）：与Java栈类似，用于存储本地方法（由非Java语言编写的方法）的调用和局部变量等信息。
5. 程序计数器（Program Counter）：用于指示当前线程所执行的字节码指令的地址。

除了上述主要的运行时数据区，还有一些辅助性的数据区，例如直接内存（Direct Memory），它是一种与Java堆外内存交互的内存区域，可以通过`ByteBuffer`进行操作。

这些运行时数据区在JVM中起着不同的作用，用于存储程序运行时的各种数据，支持Java程序的执行和内存管理。每个线程都有自己的独立的运行时数据区，而共享的数据区如方法区和堆则被所有线程共享。

## 栈帧结构与动态链接

## 为什么java堆要进行分代设计

Java堆采用分代设计是为了更好地满足不同对象的生命周期和内存分配需求。

分代设计基于以下观察和假设：
1. 大部分对象的生命周期较短：在大多数应用中，对象的生命周期往往较短。例如，很多对象在创建后很快就不再被引用，因此可以被垃圾回收。
2. 长生命周期对象的存活概率较高：一些对象的生命周期较长，而且它们的存活概率也较高。例如，一些常驻内存的缓存对象或全局对象。
3. 对象的分配和回收模式：根据观察，新创建的对象往往具有较短的生命周期，而旧的对象更有可能存活更长时间。这是因为大部分对象在创建后会经历一个"新生代"的阶段，只有少数对象能够经历多次垃圾回收后存活下来。

基于以上观察，将Java堆划分为不同的代（Generation）有助于优化内存分配和垃圾回收策略：
1. 新生代（Young Generation）：新创建的对象首先被分配到新生代。新生代采用复制算法进行垃圾回收，通过频繁地回收较短生命周期的对象，提高垃圾回收的效率。
2. 年老代（Old Generation）：经过多次垃圾回收后仍然存活的对象会被晋升到年老代。年老代的对象具有较长的生命周期和较低的存活概率，可以采用标记-清除或标记-整理算法进行垃圾回收。
3. 永久代/元空间（Permanent Generation/Metaspace）：用于存储类的元数据信息，包括类的结构、方法信息等。永久代在Java 8之后被元空间所取代。

通过分代设计，可以针对不同对象的生命周期采用不同的垃圾回收策略，提高垃圾回收的效率和整体性能。新生代通过频繁的垃圾回收保持较低的内存占用，而年老代则针对较长生命周期的对象进行垃圾回收。这样的分代设计有助于减少垃圾回收的开销，并提高应用的响应速度和吞吐量。

## 老年代的担保机制

在Java的垃圾回收中，老年代（Old Generation）担保机制是一种特殊的处理方式，用于保证在进行垃圾回收时不会因为老年代空间不足而导致内存分配失败。

在进行垃圾回收时，通常会先对新生代（Young Generation）进行垃圾回收，清理掉不再使用的对象。然后，如果新生代中的对象经过多次垃圾回收后仍然存活，就会被移动到老年代中。但是，由于老年代的空间有限，当老年代空间不足时，就会触发一次老年代的垃圾回收，即Full GC。

在进行Full GC时，如果发现老年代的空间仍然不足以容纳存活的对象，就会先检查老年代中的对象是否能够放入新生代的剩余空间中。如果可以放入新生代的剩余空间中，那么这些对象会被移动到新生代，同时会在老年代中留下一个标记，表示这些对象已经被担保，不会被回收。这个过程就是老年代的担保机制。

通过老年代的担保机制，可以保证在进行Full GC时，如果老年代空间不足，可以将部分对象移动到新生代中，以避免出现内存分配失败的情况。这种机制的实现是为了保证垃圾回收的正常进行，并防止因为内存分配失败而导致的程序异常或崩溃。

## 对象的创建过程

## 持久代与元空间以及方法区的关系

在早期的Java虚拟机版本中，Java的方法区（Method Area）被划分为永久代（Permanent Generation）和非永久代（Non-Permanent Generation）。永久代主要用于存储类的元数据信息，例如类的结构、常量池、静态变量等。而非永久代则用于存储其他一些运行时数据，如对象实例、数组等。

然而，永久代在实践中存在一些问题，比如容易出现内存溢出和性能问题。因此，从Java 8开始，Oracle对JVM做出了一些改进，将永久代替换为元空间（Metaspace），并将方法区的定义也略有变化。

元空间是一块Native内存区域，与传统的堆区和栈区不同。它用于存储类的元数据信息，包括类的结构、方法信息、字段信息等。与永久代相比，元空间具有动态扩展和释放的能力，可以根据需要自动调整大小，并且不再受到永久代固定大小的限制。

因此，可以说持久代是方法区的一部分，而方法区则可以用永久代或元空间来实现。在较新的JVM实现中，一般使用元空间来实现方法区。这样的改变带来了一些好处，如减少了内存溢出的风险、提高了垃圾回收的效率，并且可以更好地适应动态加载和卸载类的需求。

## 为什么Eden：S0：S1是8：1：1

在Java虚拟机的垃圾回收中，通常采用的是分代垃圾回收算法。其中，年轻代是对象创建的主要区域，而老年代主要存放存活时间较长的对象。

年轻代通常又被分为三个区域：Eden区和两个Survivor区（通常称为S0和S1）。对象首先在Eden区被创建，当Eden区满时，会触发一次垃圾回收，将存活的对象复制到其中一个Survivor区（通常是空的那个），同时清空Eden区。当这个Survivor区满时，会触发一次垃圾回收，将存活的对象复制到另一个Survivor区，同时清空这个Survivor区和Eden区。这样来回复制多次后，仍然存活的对象会被移到老年代。

Eden区和两个Survivor区的比例通常设置为8:1:1的原因是为了尽量减少对象在年轻代的复制次数。由于大部分对象的生命周期很短暂，很快就会被回收，因此将较大比例的空间分配给Eden区，以容纳更多的短暂对象。而Survivor区的比例相对较小，主要用于存放从Eden区复制过来的存活对象。这样的设计可以提高垃圾回收的效率，减少复制的次数和时间开销。

需要注意的是，Eden区和Survivor区的比例不是固定的，可以根据具体应用的需求进行调整。不同的应用场景可能会有不同的比例配置，以达到更好的性能和内存利用率。